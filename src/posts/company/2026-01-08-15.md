---
layout: post
title: "Celery/Redis에서 Temporal로: 멱등성 확보와 안정적인 워크플로우를 향한 여정"
date: 2026-01-08
category: Company Work
tags: Temporal Celery Redis Idempotency Architecture Python Backend
description: "KYC 프로세스의 복잡한 비동기 처리를 Celery에서 Temporal로 전환하며 멱등성을 확보하고 시스템 안정성을 높인 경험을 공유합니다."
---

분산 시스템에서 비동기 작업을 처리할 때 가장 흔히 선택되는 조합은 Celery와 Redis입니다. 저 역시 초기 KYC(Know Your Customer) 오케스트레이터 설계 당시 익숙한 Celery를 선택했습니다. 하지만 서비스가 복잡해짐에 따라 **멱등성(Idempotency)** 보장과 **복잡한 상태 관리**라는 거대한 벽에 부딪혔습니다.

이 글에서는 왜 Celery를 떠나 Temporal로 이주하게 되었는지, 그리고 그 과정에서 어떻게 멱등성을 확보했는지에 대한 기술적인 여정을 공유하고자 합니다.

---

## 1. Celery/Redis의 한계: 왜 변화가 필요했나?

### 멱등성 관리의 어려움
Celery는 "Fire and Forget" 방식에는 훌륭하지만, 네트워크 장애나 워커 다운 시 재시도(Retry) 과정에서 동일한 작업이 중복 실행될 위험이 큽니다. 특히 GPU 리소스를 많이 사용하는 얼굴 인식 작업의 경우, 중복 실행은 비용과 성능 면에서 치명적이었습니다.

### 상태의 파편화
KYC 프로세스는 다음과 같은 순서를 따릅니다:
1. 사용자가 신분증 이미지를 업로드한다.
2. 사용자가 셀카 비디오를 업로드한다.
3. 두 파일이 모두 존재할 때 얼굴 유사도를 비교한다.

Celery 환경에서는 이미지와 비디오가 언제 업로드될지 모르기 때문에, 매번 DB를 조회하거나 Redis에 중간 상태를 저장하는 복잡한 로직이 필요했습니다. "파일이 모두 모였는가?"를 체크하는 로직이 여러 곳에 흩어져 유지보수가 어려워졌습니다.

---

## 2. Temporal 도입: 오케스트레이션의 패러다임 시프트

Temporal은 단순한 메시지 큐가 아니라 **상태 저장 워크플로우(Stateful Workflows)** 엔진입니다.

### 워크플로우 중심 설계
Temporal을 도입하면서 가장 먼저 바뀐 것은 비즈니스 로직의 가시성입니다. `FaceSimilarityWorkflow`는 이제 파일이 준비될 때까지 우아하게 기다립니다.

```python
# FaceSimilarityWorkflow의 핵심 로직
@workflow.run
async def run(self, data: SimilarityData) -> SimilarityResult:
    # 이미지와 비디오가 모두 모일 때까지 최대 1시간 대기
    await workflow.wait_condition(
        lambda: any(f["type"] == "image" for f in self._files)
        and any(f["type"] == "video" for f in self._files),
        timeout=timedelta(hours=1),
    )

    # 모든 파일이 준비되면 GPU 액티비티 실행
    result = await workflow.execute_activity(
        check_face_similarity_activity,
        activity_data,
        retry_policy=RetryPolicy(maximum_attempts=3)
    )
    return result
```

이 코드는 `workflow.wait_condition`을 통해 이벤트 루프를 차단하지 않으면서도 조건이 만족될 때까지 워크플로우를 중단(Suspend)시킵니다. Celery였다면 복잡한 폴링(Polling)이나 웹훅 로직이 필요했을 부분입니다.

---

## 3. 멱등성 확보 전략: Temporal의 강력한 보장 기법

Temporal을 사용하더라도 외부 시스템(DB, API 등)과 상호작용하는 액티비티(Activity) 수준에서의 멱등성은 여전히 중요합니다. 저희는 Temporal 공식 문서에서 권장하는 베스트 프랙티스를 따라 다음과 같은 다중 방어 전략을 세웠습니다.

### 1단계: Workflow Id Reuse Policy를 통한 원천 차단
Temporal은 동일한 `Workflow Id`를 가진 워크플로우가 동시에 실행되는 것을 방지합니다. 또한 `WorkflowIdReusePolicy`를 설정하여 이미 완료된 워크플로우와 동일한 ID로 새 워크플로우를 시작하려 할 때의 동작을 제어할 수 있습니다. 이를 통해 중복 요청이 들어와도 시스템 진입점부터 멱등성을 보장받습니다.

### 2단계: Workflow Run ID와 Activity ID를 조합한 Idempotency Key
액티비티가 네트워크 오류 등으로 재시도될 때, 동일한 작업을 중복 수행하지 않도록 **Idempotency Key**를 생성합니다. Temporal 공식 문서에서는 `workflow_run_id`와 `activity_id`의 조합을 권장합니다. 이 값은 액티비티가 재시도되어도 변하지 않으며, 각 워크플로우 실행마다 고유합니다.

```python
from temporalio import activity

@activity.defn
async def check_face_similarity_activity(data: SimilarityData) -> SimilarityResult:
    info = activity.info()
    # 공식 문서 권장 방식: Run ID와 Activity ID 조합으로 고유 키 생성
    idempotency_key = f"{info.workflow_run_id}-{info.activity_id}"

    session_id = data["session_id"]

    # 생성된 키를 활용한 DB 기반 멱등성 체크
    with get_db_context() as db:
        existing = db.query(FaceSimilarity).filter(
            FaceSimilarity.idempotency_key == idempotency_key
        ).first()

        if existing:
            return SimilarityResult(success=True, message="이미 처리된 결과입니다.")

    # 실제 GPU 집약적 작업 수행...
```

### 3단계: Durable Execution과 Event History
Temporal의 **Durable Execution** 모델은 워커가 중단되어도 마지막으로 성공한 이벤트 이후부터 상태를 복구하여 재개합니다. 모든 결정(Decision)과 액티비티 결과가 **Event History**에 영구적으로 기록되므로, 시스템은 과거에 무엇을 했는지 정확히 "기억"하며 중복 작업을 회피합니다.

---

## 4. 결과: 무엇이 달라졌나?

| 비교 항목 | Celery/Redis 기반 | Temporal 기반 |
| :--- | :--- | :--- |
| **상태 관리** | DB/Redis에 수동 저장 | 워크플로우 엔진이 자동 관리 |
| **재시도 전략** | 지수 백오프 수동 구현 | 선언적 Retry Policy 적용 |
| **가시성** | 로그를 뒤져야 함 | Temporal UI에서 히스토리 확인 |
| **멱등성** | 보장하기 매우 어려움 | 구조적으로 확보 가능 |

## 결론

Celery에서 Temporal로의 전환은 단순히 도구를 바꾼 것이 아니라, **비즈니스 프로세스를 코드로 정의하는 방식**을 바꾼 것이었습니다. 특히 멱등성이 중요한 금융/인증 시스템에서 Temporal은 대체 불가능한 안정성을 제공해 주었습니다.

혹시 복잡한 비동기 로직과 멱등성 문제로 밤잠을 설치고 계신다면, Temporal로의 이주를 강력히 추천드립니다.
