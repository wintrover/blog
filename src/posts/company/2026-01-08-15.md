---
layout: post
title: "Celery/Redis에서 Temporal로: 멱등성 확보와 안정적인 워크플로우를 향한 여정"
date: 2026-01-08
category: Company Work
tags: Temporal Celery Redis Idempotency Architecture Python Backend
description: "KYC 프로세스의 복잡한 비동기 처리를 Celery에서 Temporal로 전환하며 멱등성을 확보하고 시스템 안정성을 높인 경험을 공유합니다."
---

## 서론

분산 시스템에서 비동기 작업을 처리할 때 가장 흔히 선택되는 조합은 Celery와 Redis입니다. 저 역시 초기 KYC(Know Your Customer) 오케스트레이터 설계 당시 익숙한 Celery를 선택했습니다. 하지만 서비스가 복잡해짐에 따라 **멱등성(Idempotency)** 보장과 **복잡한 상태 관리**라는 거대한 벽에 부딪혔습니다.

이 글에서는 왜 Celery를 떠나 Temporal로 이주하게 되었는지, 그리고 그 과정에서 어떻게 멱등성을 확보했는지에 대한 기술적인 여정을 공유하고자 합니다.

---

## 1. Celery/Redis의 한계: 왜 변화가 필요했나?

### 멱등성 관리의 어려움
Celery는 "Fire and Forget" 방식에는 훌륭하지만, 네트워크 장애나 워커 다운 시 재시도(Retry) 과정에서 동일한 작업이 중복 실행될 위험이 큽니다. 특히 GPU 리소스를 많이 사용하는 얼굴 인식 작업의 경우, 중복 실행은 비용과 성능 면에서 치명적이었습니다.

### 상태의 파편화
KYC 프로세스는 다음과 같은 순서를 따릅니다:
1. 사용자가 신분증 이미지를 업로드한다.
2. 사용자가 셀카 비디오를 업로드한다.
3. 두 파일이 모두 존재할 때 얼굴 유사도를 비교한다.

Celery 환경에서는 이미지와 비디오가 언제 업로드될지 모르기 때문에, 매번 DB를 조회하거나 Redis에 중간 상태를 저장하는 복잡한 로직이 필요했습니다. "파일이 모두 모였는가?"를 체크하는 로직이 여러 곳에 흩어져 유지보수가 어려워졌습니다.

---

## 2. Temporal 도입: 오케스트레이션의 패러다임 시프트

Temporal은 단순한 메시지 큐가 아니라 **상태 저장 워크플로우(Stateful Workflows)** 엔진입니다.

### 워크플로우 중심 설계
Temporal을 도입하면서 가장 먼저 바뀐 것은 비즈니스 로직의 가시성입니다. `FaceSimilarityWorkflow`는 이제 파일이 준비될 때까지 우아하게 기다립니다.

```python
# FaceSimilarityWorkflow의 핵심 로직
@workflow.run
async def run(self, data: SimilarityData) -> SimilarityResult:
    # 이미지와 비디오가 모두 모일 때까지 최대 1시간 대기
    await workflow.wait_condition(
        lambda: any(f["type"] == "image" for f in self._files)
        and any(f["type"] == "video" for f in self._files),
        timeout=timedelta(hours=1),
    )

    # 모든 파일이 준비되면 GPU 액티비티 실행
    result = await workflow.execute_activity(
        check_face_similarity_activity,
        activity_data,
        retry_policy=RetryPolicy(maximum_attempts=3)
    )
    return result
```

이 코드는 `workflow.wait_condition`을 통해 이벤트 루프를 차단하지 않으면서도 조건이 만족될 때까지 워크플로우를 중단(Suspend)시킵니다. Celery였다면 복잡한 폴링(Polling)이나 웹훅 로직이 필요했을 부분입니다.

---

## 3. 멱등성 확보 전략: 이중 방어막 구축

Temporal을 사용하더라도 액티비티(Activity) 수준에서의 멱등성은 여전히 중요합니다. 저희는 다음과 같은 이중 방어 전략을 세웠습니다.

### 1단계: Temporal의 기본 보장
Temporal은 워크플로우의 진행 상태를 이벤트 히스토리로 기록합니다. 따라서 워커가 재시작되어도 마지막으로 성공한 지점부터 정확히 재개됩니다.

### 2단계: 액티비티 내 명시적 체크
GPU 리소스를 사용하는 `check_face_similarity_activity` 내부에서는 실제 연산을 수행하기 전, DB에 이미 결과가 있는지 확인합니다.

```python
@activity.defn
async def check_face_similarity_activity(data: SimilarityData) -> SimilarityResult:
    session_id = data["session_id"]

    # 멱등성 체크: 이미 결과가 있는지 확인하여 GPU 부하 방지
    with get_db_context() as db:
        existing = db.query(FaceSimilarity).filter(
            FaceSimilarity.session_id == session_id
        ).first()

        if existing:
            return SimilarityResult(success=True, message="이미 처리된 결과입니다.")

    # 실제 GPU 집약적 작업 수행...
```

---

## 4. 결과: 무엇이 달라졌나?

| 비교 항목 | Celery/Redis 기반 | Temporal 기반 |
| :--- | :--- | :--- |
| **상태 관리** | DB/Redis에 수동 저장 | 워크플로우 엔진이 자동 관리 |
| **재시도 전략** | 지수 백오프 수동 구현 | 선언적 Retry Policy 적용 |
| **가시성** | 로그를 뒤져야 함 | Temporal UI에서 히스토리 확인 |
| **멱등성** | 보장하기 매우 어려움 | 구조적으로 확보 가능 |

## 결론

Celery에서 Temporal로의 전환은 단순히 도구를 바꾼 것이 아니라, **비즈니스 프로세스를 코드로 정의하는 방식**을 바꾼 것이었습니다. 특히 멱등성이 중요한 금융/인증 시스템에서 Temporal은 대체 불가능한 안정성을 제공해 주었습니다.

혹시 복잡한 비동기 로직과 멱등성 문제로 밤잠을 설치고 계신다면, Temporal로의 이주를 강력히 추천드립니다.
