---
layout: post
title: "Junior Developer's Full-Stack AI Journey: Completing the KYC System and Growing"
date: 2025-08-10
category: Company Work
---
Based on the Yaw angle measurement technology resolved in the last post, I completed the core functions of the KYC system. From video splitting using FFmpeg and MariaDB integration to performance optimization - I share a junior developer's full-stack challenge.

## ğŸ¯ From Problem Solving to Feature Completion: Implementing the KYC Process

![KYC Process Workflow](../assets/images/07/kyc-workflow-diagram.svg)

*Complete KYC process workflow with angle detection and video capture stages*

In my last post, I shared the struggles of improving Yaw angle measurement accuracy. This time, those efforts have paid off, and I've been focused on completing the core functionality of the KYC (Know Your Customer) system based on the resolved technology.

I started by applying the **Yaw angle measurement logic**, which was last week's biggest achievement, to the actual KYC process. I removed the `Math.random()` function that remained in the initial code and refined the calculation logic based on actual **MediaPipe** landmark data. Thanks to this, angles are now accurately measured in real-time according to the direction the user turns their head, and I was able to create robust logic for proceeding to the next step based on this.

![ê°ë„ ê°ì§€ ë‹¤ì´ì–´ê·¸ë¨](../assets/images/07/angle-detection-diagram.svg)

ìœ„ ë‹¤ì´ì–´ê·¸ë¨ì€ ì–¼êµ´ ê°ë„ ê°ì§€ ì‹œìŠ¤í…œì˜ ì‘ë™ ì›ë¦¬ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤. MediaPipeë¥¼ í†µí•´ ì–¼êµ´ ëœë“œë§ˆí¬ë¥¼ ì¶”ì¶œí•˜ê³ , 3D ì¢Œí‘œê³„ì—ì„œ yaw, pitch, roll ê°ë„ë¥¼ ê³„ì‚°í•˜ì—¬ ì‚¬ìš©ìê°€ ì˜¬ë°”ë¥¸ ë°©í–¥ì„ í–¥í•˜ê³  ìˆëŠ”ì§€ ì‹¤ì‹œê°„ìœ¼ë¡œ íŒë‹¨í•©ë‹ˆë‹¤.

### Configuration Values:
- **Front**: When yaw angle is within Â±10Â°
- **Left**: When yaw angle is within âˆ’30Â° ~ âˆ’15Â°
- **Right**: When yaw angle is within +15Â° ~ +30Â°

I completed a workflow that automatically captures video for each step when conditions are met and proceeds to the next step.

```javascript
// Yaw angle calculation logic in face-detection.js
calculateAngles(landmarks) {
    if (!landmarks || landmarks.length === 0) {
        return { yaw: 0, pitch: 0, roll: 0 };
    }

    // Actual angle calculation using MediaPipe landmarks
    const noseTip = landmarks[1];  // Nose tip
    const leftEye = landmarks[33]; // Left eye
    const rightEye = landmarks[263]; // Right eye
    
    // Yaw angle calculation (left/right rotation)
    const eyeDistance = Math.abs(leftEye.x - rightEye.x);
    const noseOffset = (noseTip.x - (leftEye.x + rightEye.x) / 2);
    const yaw = Math.atan2(noseOffset, eyeDistance) * (180 / Math.PI);
    
    return { yaw, pitch: 0, roll: 0 };
}
```

## âš™ï¸ Video Splitting and MariaDB Storage System Implementation

I focused on implementing the **video data storage** logic, which is the core of the KYC process. Initially, I considered storing the entire video on the server and then splitting it, but I changed the strategy thinking that pre-splitting by stages on the client side would be better in terms of computational efficiency. However, I ultimately adopted the approach of splitting on the server side.

![ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜](../assets/images/07/system-architecture-diagram.svg)

ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ëŠ” í”„ë¡ íŠ¸ì—”ë“œì˜ React ì»´í¬ë„ŒíŠ¸ë¶€í„° ë°±ì—”ë“œì˜ Node.js API, ê·¸ë¦¬ê³  MediaPipeë¥¼ í™œìš©í•œ ì»´í“¨í„° ë¹„ì „ ì²˜ë¦¬ê¹Œì§€ì˜ ì „ì²´ì ì¸ ë°ì´í„° íë¦„ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

I used the **fluent-ffmpeg** library on the server side to split the entire KYC video received from the client into stages. Initially, I encountered 500 errors due to FFmpeg environment variable configuration issues, but I resolved the problem by registering the correct path to PATH.

![FFmpeg Video Splitting Process](../assets/images/07/ffmpeg-video-split.svg)

*Complete FFmpeg video splitting workflow from input to database storage*

```javascript
// Video splitting using fluent-ffmpeg
ffmpeg(videoPath)
  .setStartTime(startTime)
  .setDuration(duration)
  .output(outputPath)
  .on('end', () => console.log('Video segment created successfully.'))
  .on('error', (err) => console.error('Error processing video:', err))
  .run();
```

### FFmpeg Environment Setup Resolution

To resolve FFmpeg path configuration issues in a Windows environment, I implemented the following logic:

```javascript
// Automatic FFmpeg path setting in server.js
if (process.platform === 'win32' && !process.env.FFMPEG_PATH) {
    const username = os.userInfo().username;
    const ffmpegPath = `C:\\Users\\${username}\\AppData\\Local\\Microsoft\\WinGet\\Packages\\Gyan.FFmpeg_Microsoft.Winget.Source_8wekyb3d8bbwe\\ffmpeg-7.1.1-full_build\\bin\\ffmpeg.exe`;

    try {
        require('fs').accessSync(ffmpegPath);
        process.env.FFMPEG_PATH = ffmpegPath;
        console.log('ğŸ¬ FFmpeg path set:', ffmpegPath);
    } catch (error) {
        console.warn('âš ï¸ FFmpeg path not found. Searching in system PATH.');
    }
}
```

To systematically manage KYC data, I integrated **MariaDB**. Instead of storing video files directly in the DB using BLOB format, I improved efficiency by storing only file paths.

![ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ](../assets/images/07/database-schema-diagram.svg)

ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆëŠ” ì‚¬ìš©ì ì •ë³´, KYC ì„¸ì…˜, ë¹„ë””ì˜¤ íŒŒì¼, ê°ë„ ì¸¡ì •ê°’, ê·¸ë¦¬ê³  ê°ì‚¬ ë¡œê·¸ í…Œì´ë¸” ê°„ì˜ ê´€ê³„ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤. ê° í…Œì´ë¸”ì€ ì ì ˆí•œ ì™¸ë˜ í‚¤ ê´€ê³„ë¡œ ì—°ê²°ë˜ì–´ ë°ì´í„° ë¬´ê²°ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.

```sql
CREATE TABLE kyc_records (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL,
    session_id VARCHAR(100) NOT NULL UNIQUE,
    
    -- Whole video (store only file path)
    face_whole_path VARCHAR(500),
    face_whole_size INT,
    face_whole_duration DECIMAL(10,3),
    
    -- Step-by-step video (store only file path)
    face_left_path VARCHAR(500),
    face_right_path VARCHAR(500),
    face_close_path VARCHAR(500),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

This minimized the database size and made it easier to implement additional features like video streaming in the future.

## ğŸ“ˆ Performance Optimization and Maintainability Improvement

To enhance the system's completeness, I conducted overall performance optimization and code improvement work. I replaced unnecessary popup animations and complex UI with simple text guides, and removed unnecessary repetitive operations to solve intermittent performance degradation issues.

### Real-time Processing Optimization

```javascript
// Performance optimization in face-detection.js
class FaceDetector {
    constructor() {
        // Configuration for performance optimization
        this.lastProcessTime = 0;
        this.minProcessInterval = 33; // 30fps (33ms)
        this.isProcessing = false;
        
        // Inference statistics
        this.inferenceStats = {
            totalInferences: 0,
            totalProcessingTime: 0,
            averageProcessingTime: 0,
            lastInferenceTime: 0,
            errorCount: 0
        };
    }
    
    async detectFaces(videoElementOrImageData) {
        // Skip if processing or minimum interval hasn't passed
        const now = performance.now();
        if (this.isProcessing || (now - this.lastProcessTime) < this.minProcessInterval) {
            return this.lastResults;
        }
        
        this.isProcessing = true;
        this.lastProcessTime = now;
        
        // Actual face detection logic...
    }
}
```

### Video Recording System Improvement

I implemented fallback options for browser compatibility to ensure stable operation in various environments:

```javascript
// Browser compatibility handling in video-recorder.js
class VideoRecorder {
    constructor() {
        // Fallback options for browser compatibility
        this.fallbackOptions = [
            'video/webm;codecs=vp9',
            'video/webm;codecs=vp8', 
            'video/webm',
            'video/mp4'
        ];
    }
    
    getSupportedMimeType() {
        for (const mimeType of this.fallbackOptions) {
            if (MediaRecorder.isTypeSupported(mimeType)) {
                console.log(`âœ… Supported MIME type: ${mimeType}`);
                return mimeType;
            }
        }
        console.warn('âš ï¸ No supported video MIME type found. Using default');
        return 'video/webm';
    }
}
```

## ğŸ“Š Current Status and Next Goals

Through two weeks of effort, I successfully completed the core prototype of the KYC system.

### âœ… Completed Features
- **Step-by-step KYC workflow based on Yaw angles**: Accurate angle measurement using MediaPipe landmarks
- **Video splitting and storage using Fluent-ffmpeg**: Efficient video processing on the server side
- **MariaDB integration and file path-based data management**: Performance optimization by storing paths instead of BLOBs
- **Intuitive user interface improvements**: Removal and simplification of complex animations
- **Browser compatibility and performance optimization**: Stable operation in various environments

![ê°œë°œ íƒ€ì„ë¼ì¸](../assets/images/07/development-timeline-diagram.svg)

8ì£¼ê°„ì˜ ê°œë°œ íƒ€ì„ë¼ì¸ì€ ê¸°íš ë° ì„¤ê³„ë¶€í„° ë°°í¬ê¹Œì§€ì˜ ì „ì²´ í”„ë¡œì„¸ìŠ¤ë¥¼ ë‹¨ê³„ë³„ë¡œ ë³´ì—¬ì¤ë‹ˆë‹¤. ê° ë‹¨ê³„ëŠ” ë³‘ë ¬ë¡œ ì§„í–‰ë˜ëŠ” ë¶€ë¶„ë„ ìˆì–´ íš¨ìœ¨ì ì¸ ê°œë°œì´ ê°€ëŠ¥í•˜ë„ë¡ ê³„íšë˜ì—ˆìŠµë‹ˆë‹¤.

### ğŸ¯ Next Goals

The next goal is to implement **ID card recognition** and **face comparison with the user's face** logic based on the now-completed prototype. I plan to challenge advanced features that analyze specific facial parts (eyes, nose, mouth) and compare ID card photos with real-time captured videos.

Through this project, I deeply realized the importance of **system design considering actual operational environments** beyond simple feature implementation. I was able to grow one step further by solving various technical challenges encountered in practice, especially performance optimization, browser compatibility, and data storage strategies.

---

**Tags**: #KYC #database #ffmpeg #performance-optimization #MediaPipe #MariaDB #fluent-ffmpeg #video-processing #face-detection #web-development