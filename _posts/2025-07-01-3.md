---
layout: post
title: "Django 프로젝트에 Svelte가 정말 필요할까? — 바닐라 JS와 프레임워크 도입 결정 가이드"
date: 2025-07-01 00:00:00 -0000
tags: frontend svelte javascript django seo architecture
---

## 서론

최근 사이드 프로젝트를 진행하면서 **"햄버거 메뉴·OAuth 로그인·사용자 설정"** 등 동적인 UI 요구사항이 늘어났습니다. 처음에는 순수 HTML/CSS/JavaScript(이하 *바닐라 JS*)만으로 시작했지만, 기능이 쌓이자 **상태 관리**와 **컴포넌트 재사용**이 골칫거리가 되었습니다. 그 과정에서 등장한 질문은 단순합니다.

> "Svelte(또는 SvelteKit)를 도입해야 할까, 아니면 바닐라 JS로 밀고 나갈까?"

이 글은 7.1.md 대화 내용을 토대로, **프레임워크 도입 필요성**과 **리소스 최소화** 사이에서 균형 잡힌 결정을 내리는 방법을 정리한 실무 체크리스트입니다.

---

### 1. 프레임워크가 필요한 순간

| 요구사항 | 바닐라 JS 한계 | Svelte(Kit) 장점 |
|---------|---------------|-----------------|
| 다중 컴포넌트 간 상태 공유 | `querySelector` 체인·이벤트 버스가 복잡 | `$:` 반응성, Stores 로 전역 상태↑ |
| 클라이언트-사이드 라우팅 | History API 직접 구현 필요 | 파일 기반 라우팅 내장 |
| SEO + SSR 필요 | Django 템플릿으로만 해결 시 JS 위젯은 빈 `<div>` 로 전달 | SvelteKit 서버 측 렌더 + 프리렌더 |
| 번들 최적화 | Webpack/Vite 설정 수동 | Vite 기반 빌드 + 코드 스플리팅 기본 |
| 팀·기능 확장 | 규칙 부재 → 온보딩 비용↑ | 컴포넌트·파일 구조가 관습화 |

> **요약**: 변하는 상태와 재사용 컴포넌트가 많아질수록, 그리고 SEO 까지 챙겨야 할수록 SvelteKit 이 시간을 아껴줍니다.

---

### 2. 프레임워크 없이 남는 위험

1. **스파게티 DOM** — UI 요소가 어디서 조작되는지 추적하기 어려움.
2. **상태 동기화 버그** — 로그인/로그아웃, 다크모드 같이 전역 상태가 꼬이기 쉬움.
3. **테스트 난이도** — E2E 테스트 작성 시 DOM 탐색 코드가 길어짐.
4. **번들 관리** — 파일 증가로 빌드·캐싱 전략을 매번 수동 조정해야 함.

---

### 3. 선택지 비교

```mermaid
flowchart LR
  subgraph "👟 바닐라 JS"
    A1[HTML Template] -->|DOM 조작| A2[script.js]
  end
  subgraph "🧩 Svelte 컴포넌트"
    B1[Django Template] --> B2[&lt;script src="build.js"&gt;]
    B2 --> B3[Svelte Widget]
  end
  subgraph "🚀 SvelteKit + API"
    C1[SvelteKit SSR] -->|REST| C2[Django API]
  end
```

| 모델 | 장점 | 단점 |
|------|------|------|
| **바닐라 JS** | Node 런타임 無 → 메모리↓ | 상태·라우팅 직접 구현 필요 |
| **Svelte 컴포넌트** | 인터랙티브 UI만 선택 도입 | 페이지 전환 시 전체 HTML 재로딩 |
| **SvelteKit** | SPA 느낌 + SSR·SEO 동시 해결 | Node 서버 운영·배포 비용 ↑ |

---

### 4. 리소스 최소·Python 위주 아키텍처 제안

> "SEO/GEO는 랜딩 페이지만 확보하면 되고, 무료 Northflank 티어를 쓰며, Python 중심으로 가고 싶다" 는 조건을 만족하는 현실적인 구조입니다.

1. **백엔드** — Django (템플릿 + REST API)
2. **프론트**
   * 랜딩 페이지: Django 템플릿 + 메타태그 (SEO 보장)
   * 대시보드·설정 등 인터랙티브 화면: Svelte 컴포넌트 번들 → 정적 파일로 배포
3. **빌드 파이프라인**
   ```bash
   # multi-stage Dockerfile 예시
   FROM node:20 AS client-build
   WORKDIR /app
   COPY frontend/ .
   RUN npm ci ; npm run build

   FROM python:3.11-slim AS runtime
   WORKDIR /srv
   COPY --from=client-build /app/build/ /srv/static/
   COPY requirements.txt . ; pip install --no-cache-dir -r requirements.txt
   COPY . /srv
   CMD gunicorn config.wsgi --bind 0.0.0.0:$PORT
   ```
   → **운영 컨테이너**에는 Node 런타임이 없으므로 **RAM 사용량**을 최소화할 수 있습니다.

---

### 5. 의사결정 체크리스트

- [ ] 페이지 수가 10개 이상이 될까?
- [ ] 전역 상태(로그인, 테마, 알림)가 두 곳 이상에 필요할까?
- [ ] SEO 대상 페이지가 다수인가, 아니면 랜딩 한두 개인가?
- [ ] Node 서버 추가 운영이 감당 가능한가?
- [ ] 팀에 JS 프레임워크 경험자가 있는가?

체크 항목이 **3개 이상**이라면 SvelteKit 도입이, 그렇지 않다면 *바닐라 JS + 선택적 Svelte 컴포넌트* 조합이 합리적입니다.

---

## 마무리

"프레임워크 도입 = 기술 부채를 줄이는 보험" 입니다. **초기 개발 속도**는 바닐라 JS가 빠르지만, 기능·팀 규모·SEO 요구가 커질수록 **유지보수 비용**은 기하급수적으로 늘어납니다. 

당장의 요구사항과 운영 리소스를 냉정하게 비교해 **"도입 시점"**을 결정하세요. 필요하다면 *Svelte 위젯 → SvelteKit*로 단계적 마이그레이션하는 것도 충분히 가능합니다.

> 💡 결국 중요한 건 프레임워크 유무가 아니라, **사용자에게 전달되는 가치**와 **개발팀의 생산성**입니다. 적시에 적당한 도구를 쓰는 것이 최고의 전략입니다. 