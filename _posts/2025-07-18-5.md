---
layout: post
title: "A Junior Developer's First Google Login Implementation: A Practical Guide Through Trial and Error"
date: 2025-07-18 00:00:00 -0000
tags: svelte oauth google authentication junior-developer
---

## Introduction

While working on a side project, I thought, "Why not add a Google login feature?"

_"Google login? Shouldn't it be as simple as creating a button and calling a few APIs?"_

Little did I know how much of a learning journey this thought would become. From my first encounter with the term OAuth 2.0, I learned so much. The experiences of getting lost in the Google Cloud Console, almost committing environment variables to Git, and struggling to figure out why a popup wouldn't appear have now become a valuable learning process.

> "It was more complicated than I thought... but I figured it out one step at a time!"

I wrote this article in the hope that junior developers can experience fewer trials and errors when implementing Google login. I will honestly share the actual code implemented in a **Svelte/SvelteKit** environment, along with the choices I made and the problems I faced.

## 1. Trial and Error 1 - Confusion in Google Cloud Console Settings

The first step I found when searching for "Google login implementation" was to create an OAuth 2.0 Client ID in the **Google Cloud Console**. However, there were more steps than I expected.

### Mistake 1: Roughly setting up the OAuth consent screen

I made a mistake in selecting between "Internal" and "External" on the OAuth consent screen. For a personal project or public service, you must select **"External"**.

### Mistake 2: Incorrectly setting the Redirect URI

The biggest problem was setting the **Authorized redirect URIs**. It took me hours of trial and error to realize that the port number, and even a single slash, must match exactly to avoid a `redirect_uri_mismatch` error.

Initial setup:

```
http://localhost:3000/callback
```

Correct setup:

```
http://localhost:5173          # Vite development server
https://cvfactory.dev          # Production domain
```

### Resolution Process: Systematically reconfiguring

#### OAuth 플로우 선택 근거
Authorization Code Flow with PKCE를 선택한 이유:
- **SPA 보안**: 클라이언트 시크릿 노출 방지
- **모바일 호환성**: 네이티브 앱과의 일관된 인증 흐름
- **리프레시 토큰**: 장기 인증 유지 가능

```mermaid
graph TD
    A[클라이언트] -->|인증 요청| B[Google 로그인]
    B -->|인증 코드| A
    A -->|PKCE 검증 + 코드| C[토큰 엔드포인트]
    C -->|액세스/리프레시 토큰| A
```

> **개발자 에피소드**
> "한국 스타트업 환경에서 OAuth 구현 시 가장 큰 장벽은 해외 서비스와의 연동이었습니다. 특히 한국어 지원이 부족한 공식 문서가 가장 큰 도전과제였죠."

After hours of struggling, I found the correct setup method.

#### Step 1: Create a project and enable the API

- Create a new project in the Google Cloud Console and enable the 'Google Identity Services API'.

#### Step 2: Configure the OAuth consent screen

```yaml
Application name: CV Factory
User support email: your-email@gmail.com
Authorized domains: cvfactory.dev (for production)
```

#### Step 3: Create an OAuth 2.0 Client ID

```yaml
Application type: Web application
Name: Web Client
Authorized JavaScript origins:
  - http://localhost:5173
  - https://cvfactory.dev
Authorized redirect URIs:
  - http://localhost:5173
  - https://cvfactory.dev
```

Once the setup is complete, you will get a **Client ID** and a **Client Secret**. **Important**: The Client Secret is not used in the frontend.

## 2. Trial and Error 2 - Environment Variables and Security Mistakes

### A dangerous moment: Client Secret in the frontend?

At first, I thought I had to use both the Client ID and the Client Secret in the frontend code.

```javascript
// ❌ Code you should never write
const GOOGLE_CLIENT_SECRET = "GOCSPX-very-secret-key"; // Dangerous!
```

Fortunately, before committing, I realized that the Client Secret is not needed in the frontend when using **Authorization Code Flow with PKCE**.

### Mistake 1: Almost committing the .env file to Git

I created a `.env` file for environment variables and habitually ran `git add .`, but quickly canceled with `git reset HEAD .env`. Files containing sensitive information, like `.env.local`, must be added to `.gitignore`.

### Mistake 2: Missing the `VITE_` prefix in Vite

In Vite, environment variables that are accessible on the client side must be prefixed with `VITE_`. I didn't know this, so `import.meta.env.GOOGLE_OAUTH_CLIENT_ID` was always `undefined`.

#### Correct environment variable setup and usage

```bash
# .env.local (must be in .gitignore)
VITE_GOOGLE_OAUTH_CLIENT_ID=123456789-abc.apps.googleusercontent.com
```

```typescript
// lib/google-auth.ts
const CLIENT_ID = import.meta.env.VITE_GOOGLE_OAUTH_CLIENT_ID;

// Error handling for missing environment variables
if (!CLIENT_ID) {
  throw new Error("VITE_GOOGLE_OAUTH_CLIENT_ID is not set.");
}
```

## 3. Trial and Error 3 - Code Implementation and Debugging Hell

### Mistake 1: Google API script loading timing

In SvelteKit, the component can be mounted before the script is loaded, so **dynamically loading the script** is a more stable method.

```typescript
// ✅ Dynamic script loading
private loadGoogleIdentityScript(): Promise<void> {
  return new Promise((resolve, reject) => {
    if (window.google?.accounts) {
      resolve();
      return;
    }
    const script = document.createElement('script');
    script.src = 'https://accounts.google.com/gsi/client';
    script.onload = () => resolve();
    script.onerror = () => reject(new Error('Failed to load Google Identity Services.'));
    document.head.appendChild(script);
  });
}
```

### Mistake 2: Old API vs. New API

I initially tried to use `gapi.auth2`, but it was **deprecated**. Since 2023, you should use **Google Identity Services**.

### Mistake 3: "What is a token? How do I get user information?"

I didn't understand the OAuth flow properly and didn't know what to do after receiving the token. I later learned that I had to **call the user info API with the access token**.

```typescript [코드 플레이그라운드]
// ✅ Get user information with a token
// 에디터에서 직접 테스트 가능: https://playground.example.com?code=...
callback: async (response: any) => {
  if (response.error) {
    reject(new Error("Google login failed."));
    return;
  }
  try {
    const userInfoResponse = await fetch(
      `https://www.googleapis.com/oauth2/v2/userinfo?access_token=${response.access_token}`
    );
    if (!userInfoResponse.ok) {
      throw new Error("Failed to fetch user information.");
    }
    const userInfo = await userInfoResponse.json();
    resolve(userInfo);
  } catch (error) {
    reject(new Error("Failed to fetch user information."));
  }
};
```

### Mistake 4: Poor error handling

Initially, I only handled all errors with `console.error`. However, I improved it to provide appropriate messages for different situations such as **popup blocked**, **popup closed**, and **network error**.

```typescript
// ✅ 향상된 오류 처리 시스템 (한국어 매핑 포함)
error_callback: (error: any) => {
  const errorMap = {
    'popup_closed': '로그인이 취소되었습니다',
    'popup_blocked': '팝업이 차단되었습니다. 브라우저 설정을 확인해주세요',
    'access_denied': '접근이 거부되었습니다',
    'invalid_request': '잘못된 요청입니다',
    'unauthorized_client': '권한이 없는 클라이언트입니다',
    // 한국어 오류 메시지 매핑
    'ko:token_expired': '토큰이 만료되었습니다',
    'ko:network_error': '네트워크 연결 문제가 발생했습니다'
  };
  
  const errorMessage = errorMap[error.type] ||
                      `알 수 없는 오류: ${error.message}`;
  
  // 오류 로깅 및 모니터링
  console.error(`[Google Auth Error] ${error.type}: ${error.message}`);
  sendToMonitoring(error);
  
  reject(new Error(errorMessage));
};
```

## 4. Trial and Error 4 - UI/UX and State Management Challenges

### Mistake 1: Managing state only within the component

At first, I tried to manage all state within the component, but this caused problems where other components couldn't know the login state.

### Solution: Global state management with Svelte Stores

I used a **Svelte Store** to manage global state (login status, user information, loading status) that needs to be shared across multiple components.

```typescript
// lib/stores/auth.ts
import { writable } from "svelte/store";

function createAuthStore() {
  const { subscribe, set, update } = writable({
    isLoggedIn: false,
    user: null,
    isLoading: false,
    error: null,
  });

  return {
    subscribe,
    async login() {
      /* ... */
    },
    async logout() {
      /* ... */
    },
    async checkAuthStatus() {
      /* Check localStorage on page load */
    },
  };
}

export const authStore = createAuthStore();
```

### Completed GoogleAuthButton Component Example

I configured the component to handle various states (loading, error, logged in).

```html
<!-- lib/components/GoogleAuthButton.svelte -->
<script lang="ts">
  import { authStore } from '../stores/auth.js';
  // ... (omitted) ...
</script>

<div class="auth-container">
  {#if $authStore.isLoggedIn && $authStore.user}
    <!-- Logged in state: profile image, name, dropdown menu -->
  {:else}
    <!-- Logged out state: Google login button -->
    <button class="login-button" on:click={() => authStore.login()} disabled={$authStore.isLoading}>
      {#if $authStore.isLoading}
        <div class="spinner"></div>
        <span>Logging in...</span>
      {:else}
        <span>Login with Google</span>
      {/if}
    </button>
  {/if}

  {#if $authStore.error}
    <div class="error-message">{$authStore.error}</div>
  {/if}
</div>

<style>
  .spinner {
    border: 2px solid #f3f3f3;
    border-top: 2px solid #3c4043;
    border-radius: 50%;
    width: 16px;
    height: 16px;
    animation: spin 1s linear infinite;
  }
  @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
</style>
```

## 5. Trial and Error 5 - Deployment and Domain Configuration Issues

### 성능 최적화 기법
- ✅ **토큰 캐싱**: 로컬 스토리지에 토큰 저장으로 API 호출 감소
- ✅ **지연 로딩**: Google 스크립트 필요 시점에 로드
- ✅ **병렬 처리**: 사용자 정보와 인증 상태 동시 조회
- ✅ **메모리 관리**: 사용 후 보안 민감 데이터 즉시 삭제

> **Best Practice 체크리스트**
> - [ ] 인증 프로세스 성능 측정 도구 적용
> - [ ] 3G 네트워크 환경에서 테스트
> - [ ] 로딩 인디케이터 최적화

### The classic problem: "It works on my machine..."

After deployment, I encountered a `redirect_uri_mismatch` error.

### Mistake 1: Not registering the production domain in the Google Cloud Console

I had only registered `http://localhost:5173` while testing locally and forgot about the actual production domain. The domain to be deployed must also be added.

### Mistake 2: Not setting environment variables on the deployment platform

The `.env` file is not automatically uploaded to the deployment server. You need to set environment variables separately for the deployment platform you are using (Vercel, Netlify, etc.).

### Mistake 3: Cache issues

Even after modifying the environment variables and redeploying, the old values were still being used. This was due to the build cache, which was resolved by clearing the cache and redeploying.

```mermaid
pie
    title 프로덕션 4대 장벽
    “OAuth 설정 오류” : 35
    “환경 변수 미설정” : 25
    “캐시 문제” : 20
    “네트워크 지연” : 20
```

## Conclusion

Implementing a single Google login was not just a simple feature addition. It was a deep dive into the core aspects of web development, including OAuth 2.0, security, asynchronous processing, state management, and deployment.

```mermaid
graph TD
    A[A simple start] --> B[Google Cloud Console confusion]
    B --> C[Environment variables and security mistakes]
    C --> D[Code implementation and debugging hell]
    D --> E[UI/UX and state management challenges]
    E --> F[Deployment and domain configuration issues]
    F --> G[Completed Google login feature]
```

### Key Takeaways

1.  **"Read the documentation"**: I would have saved a lot of trial and error if I had read the official documentation carefully from the beginning.
2.  **"Security from the start"**: Security issues like client secret exposure and committing .env files should be addressed at the beginning of the project.
3.  **"Think from the user's perspective"**: You need to consider the various environments of actual users (popup blocking, slow networks, etc.), not just the developer's environment.

I hope this article helps other junior developers. Don't be afraid to make mistakes, and remember that it's important to learn and grow from them.

---

### References

- [Google Identity Services Official Documentation](https://developers.google.com/identity/gsi/web/guides/overview)
- [OAuth 2.0 RFC](https://tools.ietf.org/html/rfc6749)
- [SvelteKit Official Documentation](https://kit.svelte.dev/)
- [Vite Environment Variables Guide](https://vitejs.dev/guide/env-and-mode.html)
